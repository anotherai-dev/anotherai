---
title: Building a New Agent
summary: Learn how to build AI agents with AnotherAI's unified API and observability features
description: Step-by-step guide to creating, configuring, and deploying AI agents using AnotherAI
---

## Getting Started

Because AnotherAI is an OpenAI-compatible proxy, building an agent has minimal configuration changes from standard OpenAI implementations. However there are a few things you need to know to get started.

### Base URL and AnotherAI API Key Setup

AnotherAI provides a unified API that routes requests to various AI providers. To use AnotherAI instead of calling OpenAI directly, you need to:

1. **Change the base URL** - This redirects API calls from OpenAI's servers to AnotherAI, which then routes them to the appropriate provider while adding observability features
2. **Configure your AnotherAI API key** - This enables access to AnotherAI's features

<Tabs defaultValue="cloud-hosted" items={['Cloud-Hosted', 'Self-Hosted']}>

<Tab value="cloud-hosted">

For cloud-hosted AnotherAI, use your AnotherAI API key:

```python
import openai

client = openai.OpenAI(
    base_url="https://api.anotherai.dev/v1",  # AnotherAI cloud endpoint
    api_key="aai-***",  # Your AnotherAI API key
)
```

</Tab>

<Tab value="self-hosted">

For self-hosted AnotherAI, point to your local instance with your AnotherAI API key:

```python
import openai

client = openai.OpenAI(
    base_url="http://localhost:8000/v1",  # Local AnotherAI instance
    api_key="aai-***",  # Your AnotherAI API key
)
```

</Tab>

</Tabs>

### Setting up Provider Keys

Provider keys determine which AI provider credentials AnotherAI uses to make requests to models.

**For self-hosted users**: Provider keys are required and must be configured via environment variables:

```bash
# .env file
OPENAI_API_KEY=sk-...
ANTHROPIC_API_KEY=sk-ant-...
GOOGLE_API_KEY=...
```

**For cloud users**: AnotherAI provides default provider access, but you can optionally bring your own keys for cost control or quota management through the web interface.


### Metadata

1. **Agent Identification**
In order to distinguish between different agents in AnotherAI's web view, include an `agent_id` in your agent's metadata.

```python
completion = client.chat.completions.create(
    model="gpt-4o-mini",
    messages=[{"role": "user", "content": "Analyze the sentiment of this product review"}],
    metadata={
        "agent_id": "product-review-sentiment",  # Required for observability
    }
)
```
2. **Workflow Identification**

If your agent is part of a workflow, it's recommended to include a `trace_id` and `workflow_name` in your metadata. You can read more about workflow set up [here](TODO add link once https://github.com/anotherai-dev/anotherai/pull/27 is merged).

```python
completion = client.chat.completions.create(
    model="gpt-4o-mini",
    messages=[{"role": "user", "content": "Analyze the sentiment of this product review"}],
    metadata={
        "agent_id": "product-review-sentiment",
        "workflow_name": "review-analysis-pipeline",
        "trace_id": "trace-123e4567-e89b",  # Unique ID for this workflow instance
    }
)
```


### Input and Output Design

#### 1. Input Variables

If there is variable content in your prompts, use Jinja2 templates to separate static prompts from dynamic content:

```python
completion = client.chat.completions.create(
    model="claude-3-5-sonnet-20241022",
    messages=[{
        "role": "user", 
        "content": "Analyze the sentiment of this product review: {{review_text}}"
    }],
    extra_body={
        "input": {
            "review_text": "This product exceeded my expectations! The quality is amazing..."
        }
    },
    metadata={
        "agent_id": "product-review-sentiment",
        "workflow_name": "review-analysis-pipeline",
        "trace_id": "trace-123e4567-e89b",
    }
)
```

#### 2. Structured Outputs

Structured outputs aren't required, but they're highly recommended, especially for agents that have multiple output fields.

```python
from pydantic import BaseModel
from enum import Enum

class Sentiment(str, Enum):
    positive = "positive"
    negative = "negative"
    mixed = "mixed"

class SentimentAnalysis(BaseModel):
    sentiment: Sentiment
    explanation: str  # Why this sentiment was determined

completion = client.beta.chat.completions.parse(
    model="gpt-4o",
    messages=[{
        "role": "user", 
        "content": "Analyze the sentiment of this product review: {{review_text}}"
    }],
    response_format=SentimentAnalysis,
    extra_body={
        "input": {
            "review_text": "This product exceeded my expectations! The quality is amazing..."
        }
    },
    metadata={
        "agent_id": "product-review-sentiment",
        "workflow_name": "review-analysis-pipeline",
        "trace_id": "trace-123e4567-e89b",
    }
)

result = completion.choices[0].message.parsed
```

### Next Steps

- [Test your agent with experiments](/docs/agents/evaluating)
- [Improve your agent with annotations](/docs/agents/improving)
- [Evaluate agent performance](/docs/agents/evaluating)