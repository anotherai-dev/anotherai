---
title: Building a New Agent
summary: Learn how to build AI agents with AnotherAI's unified API and observability features
description: Step-by-step guide to creating, configuring, and deploying AI agents using AnotherAI
---

## Getting Started

Because AnotherAI is an OpenAI-compatible proxy, building an agent has minimal configuration changes from standard OpenAI implementations. However there are a few things you need to know to get started.

### Base URL and API Key Setup

AnotherAI provides a unified API that routes requests to various AI providers. To use AnotherAI instead of calling OpenAI directly, you need to:

1. **Change the base URL** - This redirects API calls from OpenAI's servers to AnotherAI, which then routes them to the appropriate provider while adding observability features
2. **Configure API keys** - Either your own provider keys (self-hosted) or an AnotherAI key (cloud-hosted)

The setup differs between deployments:
- **Self-hosted**: You manage provider API keys, AnotherAI runs on your infrastructure
- **Cloud-hosted**: AnotherAI manages provider keys, you only need an AnotherAI API key

<Tabs defaultValue="self-hosted" items={['Self-Hosted', 'Cloud-Hosted']}>

<Tab value="self-hosted">

Configure provider API keys in your `.env` file:

```bash
# .env file
OPENAI_API_KEY=sk-...
ANTHROPIC_API_KEY=sk-ant-...
```

Then point the OpenAI client to your local AnotherAI instance:

```python
import openai
import os

# Configure OpenAI client for AnotherAI
openai.api_key = os.environ.get("OPENAI_API_KEY")
openai.base_url = "http://localhost:8000/v1"  # Local AnotherAI instance

# Create client instance
client = openai.OpenAI()
```

</Tab>

<Tab value="cloud-hosted">

Use your AnotherAI API key (no provider keys needed):

```python
import openai

client = openai.OpenAI(
    base_url="https://api.anotherai.dev/v1",  # AnotherAI cloud endpoint
    api_key="aai-***",  # Your AnotherAI API key
)
```

</Tab>

</Tabs>


### Metadata

1. **Agent Identification**
In order to distinguish between different agents in AnotherAI's web view, include an `agent_id` in your agent's metadata.

```python
completion = client.chat.completions.create(
    model="gpt-4o-mini",
    messages=[{"role": "user", "content": "Analyze the sentiment of this product review"}],
    metadata={
        "agent_id": "product-review-sentiment",  # Required for observability
    }
)
```
2. **Workflow Identification**

If your agent is part of a workflow, it's recommended to include a `trace_id` and `workflow_name` in your metadata. You can read more about workflow set up [here](TODO add link once https://github.com/anotherai-dev/anotherai/pull/27 is merged).

```python
completion = client.chat.completions.create(
    model="gpt-4o-mini",
    messages=[{"role": "user", "content": "Analyze the sentiment of this product review"}],
    metadata={
        "agent_id": "product-review-sentiment",
        "workflow_name": "review-analysis-pipeline",
        "trace_id": "trace-123e4567-e89b",  # Unique ID for this workflow instance
    }
)
```


### Input and Output Design

#### 1. Input Variables

If there is variable content in your prompts, use Jinja2 templates to separate static prompts from dynamic content:

```python
completion = client.chat.completions.create(
    model="claude-3-5-sonnet-20241022",
    messages=[{
        "role": "user", 
        "content": "Analyze the sentiment of this product review: {{review_text}}"
    }],
    extra_body={
        "input": {
            "review_text": "This product exceeded my expectations! The quality is amazing..."
        }
    },
    metadata={
        "agent_id": "product-review-sentiment",
        "workflow_name": "review-analysis-pipeline",
        "trace_id": "trace-123e4567-e89b",
    }
)
```

#### 2. Structured Outputs

Structured outputs aren't required, but they're highly recommended, especially for agents that have multiple output fields.

```python
from pydantic import BaseModel
from enum import Enum

class Sentiment(str, Enum):
    positive = "positive"
    negative = "negative"
    mixed = "mixed"

class SentimentAnalysis(BaseModel):
    sentiment: Sentiment
    explanation: str  # Why this sentiment was determined

completion = client.beta.chat.completions.parse(
    model="gpt-4o",
    messages=[{
        "role": "user", 
        "content": "Analyze the sentiment of this product review: {{review_text}}"
    }],
    response_format=SentimentAnalysis,
    extra_body={
        "input": {
            "review_text": "This product exceeded my expectations! The quality is amazing..."
        }
    },
    metadata={
        "agent_id": "product-review-sentiment",
        "workflow_name": "review-analysis-pipeline",
        "trace_id": "trace-123e4567-e89b",
    }
)

result = completion.choices[0].message.parsed
```

### Next Steps

- [Test your agent with experiments](/docs/agents/evaluating)
- [Improve your agent with annotations](/docs/agents/improving)
- [Evaluate agent performance](/docs/agents/evaluating)